注释：（+）:后续学习需要在此部分补充知识
tips: 成员函数：
		成员函数的声明必须在类的内部，定义既可以在类的内部也可以在类的外部。其中定义在类的内部的函数为隐式的inline。
	    成员函数通过this隐式形参来访问调用它的对象。编译器将对象地址传给该形参。在成员函数内部我们可以直接使用该对象的成员，而无需使用this（不过合法）。
	    this是常量指针，可以通过在成员函数形参列表后+const将该形参变为指向常量的常量指针。
		在类的外部定义的函数需要使用作用域操作符指明其所属的类型
		定义一个成员函数时的流程（zz）：
			1 返回类型：（引用？）
			2 声明：形参类型（引用？）
			3 是否为常量成员函数（尾置const）
			4 否在类内定义（inline函数？定义在类外部的函数也可以在类内部声明时前+inline显示的声明为inline函数）;在类外定义要加上作用域：类名。因此必须出现在类的声明之后
			5 是否重载？
		
	  非成员函数：
		属于类的接口的非成员函数的声明应该和类的声明在同一个头文件中。定义一个非成员函数要考虑其是否是类的友元。
	
	  名字查找：
		对于类内部的成员函数，会先编译成员的声明，全部可见后再编译函数体。而并不只考虑之前出现过的声明
		在类的外层作用域定义的名字不能在类内重新定义。
	   
1.类的基本思想（+）
类的基本思想是数据抽象与封装,以及继承。他们实现了类的接口，即用户所能执行的操作和类的实现，即实现类的数据成员，函数体和定义类所需要的私有函数的分离。
类的封装防止用户破坏对象成员的状态，也方便调整细节实现部分的代码而不需要修改用户级别的代码。
继承让我们声明一个派生类继承自一个基类。该派生类可以当作基类使用。

2.简述构造函数（+）
构造函数是类用于初始化数据成员的函数。它在类的对象创建的时候执行。
相比于普通成员函数，没有返回值类型，其名字和类名相同，不能被声明为const。可以在类的构造时向其const对象写值。还包含一个初始值列表（冒号和花括号之间），用以初始化初值。
没由出现在初始值列表中的变量将使用类内初始值初始化或执行默认初始化。因此如果一个数据成员仅出现在默认构造函数体中，它先被默认初始化，再通过函数体内的操作被赋值。
初始值列表不指定成员初始化的顺序，顺序由类定义的顺序相同。因此用一个值初始化另一个值是，该顺序很重要。
如果一个构造函数为所有实参都提供了默认值，那么 它实际定义了默认构造函数。
默认构造函数：一个被类用于控制默认初始化过程的函数。由编译器合成的默认构造函数称为合成的默认构造函数。并不是所有情况下都能使用合成默认构造函数：
	当只有编译器发现类内不包含任何构造函数时才会合成，即如果我们定义了其他构造函数而不定义默认构造函数将会没有默认构造函数，此时可以通过“=default”来让编译器合成一个默认构造函数（和声明放在类内为inline，也可以和定义放在类外）；且其对类的内置和合成类型成员执行默认初始化可能导致值的未定义。因此可能需要我们自定义默认构造函数；最后，类内的一个成员类型是一个其他没有默认构造函数的类的类型，则该成员无法被该合成构造函数初始化。

委托构造函数：
使用所属类的其他构造函数完成初始化的过程
先执行受委托的函数从初始值列表，再执行其函数体，再执行委托函数的函数体

定义构造函数流程：（zz）
	1 是否需要定义默认构造函数
	2 其他构造函数
		1 确定接受的参数
		2 构造函数初始值列表
		3 是否在类内定义
		4 函数体

转换构造函数：
如果一个构造函数只接受一个实参，则实际上其定义了转换为此类类型的隐式转换机制。然而只会进行一步转换。可以在构造函数开头加explicit不定义隐式转换。此时亦不能使用该构造函数进行该类拷贝初始化。可以使用static_cast强制先行转换为类类型。

4.拷贝，赋值和析构（+）
如果我们不主动定义这些操作，编译器会合成他们，对每个类的成员进行拷贝，赋值和销毁。类需要分配类之外的资源时，合成版本常会失效。

5.成员说明符：
用以对类进行封装
Public: 之后的成员可以被整个程序访问
Private: 仅能被类的成员函数访问

使用typedef和using定义的类型别名也拥有两种访问权限中的一种


6. class和struct关键字
唯一区别在于在第一个访问说明符定义的成员的默认访问权限。class中为私有，struct中为公有。一般来说，仅希望所有成员为公有的才使用struct

7. 友元：
类的友元为其他函数和类或类的成员函数，赋予其访问该类私有成员的权限
友元不具有传递性
定义在类内部的友元函数是隐式内联的，然而其仍需再声明一次才能在之后使用。
对一组重载函数声明友元必须对每个函数声明友元

格式：
friend + 声明语句。然而友元声明不能用作声明语句，即用户无法访问友元。为使用户能够调用某个友元，我们在类的头文件中重新进行声明
其可以在类的任意位置出现，但一般放在类的开始或结束。

8.mutable关键字
当我们希望一个类的数据成员能够通过const成员函数修改时，使用mutable。

9. 什么是不完全类型
仅被声明而未被定义的类的类型。
可以定义指向这种类型对象的指针或引用，也可以 声明 返回类型为这种类型的函数。因此一个类的类成员类型不能是自己，但能包含一个指向自身类型对象的引用或指针。

9.什么是聚合类
所有成员都是公有的
未定义任何构造函数
无类内初始值
无基类和virtual函数

对聚合类可以使用{}来初始化。初始值顺序必须与声明顺序一致。当少于声明的数量时，剩余的成员执行值初始化。

10.字面值常量类
（1）数据成员都是字面值的聚合类
（2）对于非聚合类：
	 数据成员都为字面值
	 至少含有一个constexpr构造函数
	 如果有类内初始值
		内置类型成员初始值必须为常量表达式
		类类型成员使用constexpr构造函数初始化
	使用析构函数的默认定义

constexpr构造函数可以使用=default或删除函数的形式。否则其函数体一般为空
其必须使用constexpr构造函数或常量表达式作为初始值，初始化所有数据成员。

11.类的静态成员
只在类而不在其对象中储存的成员。静态函数成员不包括this指针。使用static关键字声明，该关键字只应该在类内声明/定义时出现一次。
我们可以作用域运算符，类的对象+‘.’或指向类的对象的指针+‘->’访问该静态对象
对于数据静态成员，一般使用类的成员函数初始化（由于其并不会经由构造函数初始化），而static constexpr int类型可以由const int类型类内初始值初始化。
相比于普通类成员，静态数据类成员类型可以是不完全类型（即可以使用该类类型），也可以作为默认实参。

12. IO头文件和类型
3个头文件，12个类型
iostream是fstream的基类，因此在要求使用iostream的情况下可以用fstream代替（当然功能会改变）

13. IO条件状态
strm::iostate 机器相关的类型，提供表达条件状态的完整功能。IO库定义了四个此类型的constexpr值
strm::badbit 系统级错误，不可恢复,此时.bad(), .fail()返回true
strm::failbit 可恢复错误, 此时.fail()返回true
strm::eofbit 达到文件末尾，failbit亦会被置位，此时.eof(), .fail()返回true
以上任一被置位，则检测流的条件状态为0
strm::goodbit 为0表示未发生错误，此时.good()返回true
因此可以用.good()与.fail()判断是否发生错误

此外还有.clear()和.rdstate()来复位/读取状态

14. 输出流缓冲机制
操作系统可以将文本串存储在缓冲区之后将原本多次的写操作整合为一次。由于设备的写操作可能耗费很多时间，因此这方便提升性能。
以下五种情况会导致缓冲区刷新：
程序正常结束，作为main函数的return语句
缓冲区满时
使用如endl等操纵符
使用unitbuf操纵符设置流的内部状态，如cerr。使用形如cout << unitbuf会禁用缓冲区机制
输出流被关联到另一个流时，例如读cin和写cerr会导致cout缓冲区刷新。使用流的.tie()方法可以使一个输入流关联/取消关联到输出流，也可以关联/取消关联两个输出流

15. flush endl ends区别
三种操纵符都会显示的刷新输出流缓冲区
flush不输出任何额外字符
endl输出一个换行符
ends输出一个空字符

16. 什么是顺序容器
顺序容器提供控制容器存储和访问顺序的能力，这种顺序仅取决于元素存入容器的时的位置
STL中的顺序容器(6种)
vector string deque list forward_list array

17. STL种array和内置数组的区别
array支持赋值和拷贝，前提时保证储存的元素类型和容器大小两个对象相同

18. 容器适配器
基于底层的STL容器实现，通过改变接口使其操作类似于另一种类型
stack queue priority_queue