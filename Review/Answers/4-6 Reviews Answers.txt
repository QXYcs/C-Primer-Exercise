注释：（+）:后续学习需要在此部分补充知识
tips: m%n返回值符号和m相同
	  case语句：
	  case的标签必须是一个整型常量表达式。标签不应单独出现，后面应跟一条语句或另一个标签。所以default标签后要接空语句。
	  case 0:{}则在语句块之内定义变量只在{}内起作用。不加{}则在所有case和dafault标签中起作用。不允许跳过变量的初始化直
	  接到该变量作用域的另一处所以case语句定义变量要使用语句块
	  
	  range for语句:
	  C++11标准新引入
	  for (declaration : expression)
	  expression必须是一个能返回迭代器begin和end的序列。
	  例如花括号括起来的初始值列表 vector string 数组等。range for中预存了end()的值，如果通过其增删容器的对象可能会使此值无效
	  
	  goto语句：
	  无条件跳转到一个带标签语句，和switch case相同，不允许跳过变量的初始化直接到该变量作用域的另一处。
	   
	  try catch语句:
	   try{
	   throw XXXX(""); ///throw表达式包含throw关键字和其后紧跟的一个异常类型的对象
	   }catch(一个异常声明){///选定后执行对应的块
	   }catch(一个异常声明){
	   }...
	   ///执行完后执行后续代码，出现异常却没有被捕捉到会调用标准库函数terminate终止当前程序执行
	   对比assert: assert是预处理宏，assert(expr);为真/定义了预处理变量NDEBUG：什么也不做；否则终止程序，输出信息
	   
	   标准异常：
	   c++标准定义了一组异常类，报告使用标准库遇到的问题。用户可以编程使用，分别定义在四个头文件：
	   exception  stdexcept  new  type_info （+）。对stdexcept对象必须提供string对象或c风格字符串初始化，其他类型的对象必须默认初始化。
	   他们都有一个what函数成员。提供初始值时返回该初始值，否则返回内容由异常类型和编译器决定。
	   
	   函数：
	   （1）函数形参尽量定义为常量引用，不行则定义成引用，再则非引用。对指针同样适用
	   （2）return:
			返回一个未命名的临时对象。不能返回一个局部变量指针或引用
	   （3）返回类型是引用时返回左值，否则返回右值
	   （4）可以使用列表初始化返回的对象。如果是内置类型，{}内只能有一个值
	   （5）c++11中有尾置返回类型的方法。任何返回类型的函数都可以使用，对于复杂的返回类型尤其适用：
	        auto a() -> int (*)[10]; ///等效于使用decltype:
			decltype(arr) *a();
	   （6）用作默认实参的名字在函数的作用域内解析，其求值也发生在函数调用过程
	   
1.简述重载运算符
C++定义了内置类型和复合类型的运算符。当运算符作用于类的时候用户自行定义的过程称为运算符重载。允许用户定义运算对象的类型
和返回值的类型。但是无法更改优先级和结合律。

2.简述c和c++中的右值和左值及c++中两者区别和联系（+）
c中根据能否放在赋值语句的左侧和右侧区别左值和右值。
c++中不然。例如一个常量对象是左值而无法放在赋值语句的左侧。
c++中左值可以理解为能被取地址和引用的对象，关注其内存中的位置。右值反之，关注其内容。

联系：
右值可以用左值代替而反之不行


3.简述结合律 优先级 和求值顺序
优先级和结合律规定了在复合表达式中运算对象的结合顺序。高优先级的运算符和其运算对象
首先组合。优先级相同则依照左或右结合律从左或右一次组合。

只有四种运算符规定了求值顺序：逻辑或，逻辑与，条件运算符，逗号运算符。
对于其他运算符，如果一个复合表达式中的子表达式指向并修改同一个对象将会产生
未定义行为。

4.算数类型包括？
整型和浮点型

5. 隐式转换的规则：
算术类型中：
（1）大多数表达式中小于int的整型提升为较大整型
（2）条件中非bool转化为bool型
（3）初始化和赋值过程，左侧对象类型转化成右侧对象类型
（4）算术或关系运算中如果有多种类型会转化为同意类型，并尽量避免精度损失
（5）算术类型转化的详细规则：
     （1）整型提升：
		  bool ((un)signed) char (un)signed short提升为能int及unsigned int中较小的能装下他们所有可能值的那个。
	
	      wchar_t char16_t char64_t提升为 int uint long ulong, longlong, ulonglong较小的能装下他们所有可能值的那个。
		  
	 （2）无符号和带符号类型的相互转化
		  下一步则是对于一个运算符的相关运算对象。如果执行完整型提升后他们全为无符号或带符号，则小类型转化为大类型。
		  否则若其中带符号类型能存储无符号类型的所有可能值则转化为带符号类型
		  否则转化为无符号类型。


其他类型：
（1）数组除非用作decltype关键字的参数及 & sizeof typeid运算符运算对象及用引用初始化数组（int (&arrRef)[10] = arr），将转换为指针。
（2）将函数名作为值使用时(fun没有括号，等价于&fun)，将转化为指针，即存放其的地址值
（3）0/nullptr可转化为任意指针类型。指向任意非常量对象的指针可转化为void*,而指向任意对象的指针可转化为const void*(尽量使用const void*)
（4）非常量引用可转化为常量引用，反之不行。
（5）类类型（+）

6.强制类型转化
cast-name<type>(expression)
static_cast:不包含底层const即可
const_cast:只能改变底层const属性，不能顺带改变其他类型
reinterpret_cast:对对象的位模式提供较低层次的重新解释 会导致比如说一个char*用此方法存储的实际上是一个int*，而编译器却不知道。使类型说明符失去了作用。

7.对象的生命周期：
程序执行的过程中，对象存在的一段时间

8.简述局部变量 静态对象和自动对象
（1）局部变量指仅在函数作用域内可见的变量
其对应的对象分为两种: 自动对象和局部静态对象
（2）自动对象在函数的控制路径经过变量的定义语句时创建它，在函数调用结束时销毁它。它仅存在于块执行的期间。其若被初始化则执行默认初始化（内置类型对象值被初始化为0）
（3）局部静态对象被定义为static类型，它的生命周期贯穿函数执行及之后的时间。未被初始化时会执行值初始化（内置类型被初始化为0）

9.函数声明（函数原型）和定义的区别
（1）一个函数可以被声明多次但只能定义一次
（2）函数声明无需函数体，而以分号结束。也无需形参名

10.如何定义含有可变形参的函数（+）
（1）如果所有实参类型相同，使用C++11提供的initializer_list标准库类型：
void a(initializer_list<int> a1);
a({1, 2, 3})
（2）若不同，则自定义模板类型他们都有一个what函数成员。提供初始值时返回该初始值，否则返回内容由异常类型和编译器决定。
（3）访问某些特殊的c代码，使用省略符形参,其用到了c标准库中的功能：
void b(int b1, int b2...)

11.简述重载函数和调用重载函数的过程：
重载函数：名字相同而形参列表不同的一组函数。
调用时先对该一作用域中的函数进行函数匹配。没有则在更外层作用域中寻找。
函数匹配：
（1）确定候选函数：同名在调用点可见的函数
（2）确定可行函数：形参与提供的实参数量相等，且类型相同或可以相互转化
（3）寻找最佳匹配：与本次调用最匹配的函数：优先级：
    （1）精确匹配：形实类型相同/数组或函数类型->对应指针/顶层const的增删
	（2）通过底层const转化实现的匹配
	（3）通过整型提升实现的匹配
	（4）通过算数类型转化/指针转化的匹配
	（5）类类型转化的匹配
若有多个最佳函数会造成二义性调用的错误

12.简述内联函数：
内联函数用inline关键字定义，它将函数在调用点上内联的展开，节省调用一般函数的开销
inline是一个请求。如果编译器不支持某个函数的内联时将会忽略这个请求。
其和constexpr函数都应定义在头文件中。

13.简述constexpr函数：
constexpr函数指能用于常量表达式的函数。其形参和返回值必须是字面值类型（不一定是常量）。且只能包含一条语句--return语句。包含其他语句时，其他语句
在运行时不能执行任何操作（空语句 别名）